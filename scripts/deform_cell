#!/usr/bin/env python3
import argparse
import numpy as np
import pw2py as pw

def parse_command_line():
    ''' parse command line options '''
    parser = argparse.ArgumentParser(
        description="Create Gaussian wrinkle or Gaussian bump in a supercell"
    )
    parser.add_argument(
        'qefile', metavar='qefile', type=str, 
        help="path to quantum espresso inp/out file"
    )
    parser.add_argument(
        '-s', '--shape', metavar='arg', type=str, 
        help="shape of the deformation"
    )
    parser.add_argument(
        '-amp', '--amplitude', metavar='arg', type=float, 
        help="amplitude of the gaussian wrinkle or bump (angstrom)",
        default=1.0
    )
    parser.add_argument(
        '-std', '--standard_deviation', metavar='arg', type=float, 
        help="standard deviation of the gaussian wrinkle or bump (angstrom)",
        default=1.0
    )
    parser.add_argument(
        '-p', '--peak', metavar='arg', nargs='+', type=float,
        help="peak position (e.g. -p 1 1) of the gaussian wrinkle or bump (angstrom)",
        default=[0, 0]
    )
    parser.add_argument(
        '-r', '--rotation', metavar='arg', type=float, 
        help="rotation angle (degree) with respect to y-axis",
        default=0
    )
    return parser.parse_args()


def gaussian(amp, std, peak, x):
    """
    amp (amplitude of gaussian function)
    std (standard deviation)
    peak (peak position)
    """
    x = np.asarray(x)
    y = amp * np.exp(-0.5*(x-peak)**2/std**2)
    return(y)


def curvature_gaussian(amp, std, t=np.linspace(-10, 10, 1000)):
    """
    This function is used for estimating the curvature of gaussian 
    x(t) = t
    y(t) = amp * exp(-1/2 * (t^2) / std^2)
    """
    dx_dt = 1
    d2x_dt2 = 0
    dy_dt = -t / std**2 * amp * np.exp(-0.5 * t**2 / std**2)
    d2y_dt2 = (
        t**2 / std**4 - 1 / std**2) * amp * np.exp(-0.5 * t**2 / std**2
    )
    curvature = np.abs(
        (d2x_dt2*dy_dt - dx_dt*d2y_dt2)/(dx_dt**2 + dy_dt**2)**1.5
    )
    curvature = round(np.amax(curvature), 3)
    print("The largest curvature = {} A^-1".format(curvature))


def gaussian_wrinkle(geo: pw.atomgeo, amp=1.0, std=1.0, peak=[0, 0], theta=0):
    """
    =-----------------------------------------------------------------------
    Deform the 2D supercell by creating a gaussian-shaped wrinkle
    along x-axis.
    z += gaussian(amp, std, peak[1], y)
    
    Define atomic positions in cartisian coordinate as A, rotation matrix as R.
    Rotate matrix A by RA^T, then transform  the supercell, finally rotate back 
    the transformed supercell R^{-1}RA^T.
    =-----------------------------------------------------------------------
    """
    theta = theta / 180.0 * np.pi
    rotation_mat = np.matrix(
        [
            [np.cos(theta), -np.sin(theta), 0], 
            [np.sin(theta), np.cos(theta), 0],
            [0, 0, 1]
        ]
    )
    inv_rotation_mat = np.linalg.inv(rotation_mat)

    original_pos_unit = geo.pos_units
    geo.pos_units = "angstrom"

    geo.pos = np.matmul(geo.pos, np.transpose(rotation_mat))
    geo.pos[:, 2] += gaussian(amp, std, peak[1], geo.pos[:, 1])
    geo.pos = np.matmul(geo.pos, np.transpose(inv_rotation_mat))
    geo.pos_units = original_pos_unit
    return(geo.pos)

def gaussian_bump(geo: pw.atomgeo, amp=1.0, std=1.0, peak=[0, 0]):
    """
    =-----------------------------------------------------------------------
    Deform the 2D supercell by creating a gaussian-shaped bump.
    z += gaussian(amp, std, peak[0], y) * gaussian(amp, std, peak[1], y)
    The actual amplitude of the gaussian bump is amp**2.
    =-----------------------------------------------------------------------
    """
    original_pos_unit = geo.pos_units
    geo.pos_units = "angstrom"
    geo.pos[:, 2] += (
        gaussian(amp, std, peak[0], geo.pos[:, 0]) 
        * gaussian(amp, std, peak[1], geo.pos[:, 1])
    )
    geo.pos_units = original_pos_unit
    return(geo.pos)


if __name__ == "__main__":
    args = parse_command_line()
    geo = pw.atomgeo.from_file(args.qefile)
    
    if args.shape == "wrinkle":
        geo.pos = gaussian_wrinkle(
            geo, amp=args.amplitude, std=args.standard_deviation, 
            peak=args.peak, theta=args.rotation
        )
        curvature_gaussian(
            amp=args.amplitude, std=args.standard_deviation
        )
    elif args.shape == "bump":
        geo.pos = gaussian_bump(
            geo, amp=args.amplitude, std=args.standard_deviation, 
            peak=args.peak
        )
        curvature_gaussian(
            amp=(args.amplitude)**2, std=args.standard_deviation
        )
    else:
        print("Currently only shape of wrinkle and bump are supported.")
    
    print("Saving deformed geometry file")
    outfile = "gaussian_" + args.shape
    geo.write_file(outfile)
    
